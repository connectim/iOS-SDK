// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Message.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MessageRoot

@implementation MessageRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - MessageRoot_FileDescriptor

static GPBFileDescriptor *MessageRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum ChatType

GPBEnumDescriptor *ChatType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Private\000Groupchat\000ConnectSystem\000";
    static const int32_t values[] = {
        ChatType_Private,
        ChatType_Groupchat,
        ChatType_ConnectSystem,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChatType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChatType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChatType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChatType_Private:
    case ChatType_Groupchat:
    case ChatType_ConnectSystem:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - NewConnection

@implementation NewConnection

@dynamic salt;
@dynamic pubKey;

typedef struct NewConnection__storage_ {
  uint32_t _has_storage_[1];
  NSData *salt;
  NSData *pubKey;
} NewConnection__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "salt",
        .dataTypeSpecific.className = NULL,
        .number = NewConnection_FieldNumber_Salt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewConnection__storage_, salt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = NewConnection_FieldNumber_PubKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewConnection__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewConnection class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewConnection__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMRequest

@implementation IMRequest

@dynamic pubKey;
@dynamic sign;
@dynamic hasCipherData, cipherData;

typedef struct IMRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubKey;
  NSString *sign;
  GcmData *cipherData;
} IMRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = IMRequest_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMRequest__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = IMRequest_FieldNumber_Sign,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMRequest__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cipherData",
        .dataTypeSpecific.className = GPBStringifySymbol(GcmData),
        .number = IMRequest_FieldNumber_CipherData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMRequest__storage_, cipherData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMRequest class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeviceInfo

@implementation DeviceInfo

@dynamic deviceId;
@dynamic deviceName;
@dynamic locale;
@dynamic cv;
@dynamic uuid;
@dynamic hasChatCookieData, chatCookieData;

typedef struct DeviceInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t cv;
  NSString *deviceId;
  NSString *deviceName;
  NSString *locale;
  NSString *uuid;
  ChatCookieData *chatCookieData;
} DeviceInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = DeviceInfo_FieldNumber_DeviceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, deviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = DeviceInfo_FieldNumber_DeviceName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "locale",
        .dataTypeSpecific.className = NULL,
        .number = DeviceInfo_FieldNumber_Locale,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, locale),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cv",
        .dataTypeSpecific.className = NULL,
        .number = DeviceInfo_FieldNumber_Cv,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, cv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = DeviceInfo_FieldNumber_Uuid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chatCookieData",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatCookieData),
        .number = DeviceInfo_FieldNumber_ChatCookieData,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, chatCookieData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeviceInfo class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeviceInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\010\000\002\n\000\006\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemoveRelationship

@implementation RemoveRelationship

@dynamic uid;

typedef struct RemoveRelationship__storage_ {
  uint32_t _has_storage_[1];
  NSString *uid;
} RemoveRelationship__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = RemoveRelationship_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RemoveRelationship__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemoveRelationship class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemoveRelationship__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SettingFriendInfo

@implementation SettingFriendInfo

@dynamic uid;
@dynamic remark;
@dynamic common;

typedef struct SettingFriendInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *uid;
  NSString *remark;
} SettingFriendInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = SettingFriendInfo_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SettingFriendInfo__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = SettingFriendInfo_FieldNumber_Remark,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SettingFriendInfo__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "common",
        .dataTypeSpecific.className = NULL,
        .number = SettingFriendInfo_FieldNumber_Common,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SettingFriendInfo class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SettingFriendInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddFriendRequest

@implementation AddFriendRequest

@dynamic uid;
@dynamic tips;
@dynamic source;

typedef struct AddFriendRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t source;
  NSString *uid;
  NSString *tips;
} AddFriendRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = AddFriendRequest_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddFriendRequest__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = AddFriendRequest_FieldNumber_Tips,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddFriendRequest__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = AddFriendRequest_FieldNumber_Source,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AddFriendRequest__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddFriendRequest class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddFriendRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExternalBillingToken

@implementation ExternalBillingToken

@dynamic token;

typedef struct ExternalBillingToken__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} ExternalBillingToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBillingToken_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExternalBillingToken__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExternalBillingToken class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExternalBillingToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RedPackageToken

@implementation RedPackageToken

@dynamic token;

typedef struct RedPackageToken__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} RedPackageToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = RedPackageToken_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedPackageToken__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedPackageToken class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedPackageToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncRelationship

@implementation SyncRelationship

@dynamic version;

typedef struct SyncRelationship__storage_ {
  uint32_t _has_storage_[1];
  NSString *version;
} SyncRelationship__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = SyncRelationship_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncRelationship__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SyncRelationship class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncRelationship__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AcceptFriendRequest

@implementation AcceptFriendRequest

@dynamic uid;
@dynamic source;

typedef struct AcceptFriendRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t source;
  NSString *uid;
} AcceptFriendRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = AcceptFriendRequest_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AcceptFriendRequest__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = AcceptFriendRequest_FieldNumber_Source,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AcceptFriendRequest__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AcceptFriendRequest class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AcceptFriendRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FriendChatCookie

@implementation FriendChatCookie

@dynamic uid;
@dynamic pubkey;

typedef struct FriendChatCookie__storage_ {
  uint32_t _has_storage_[1];
  NSString *uid;
  NSString *pubkey;
} FriendChatCookie__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = FriendChatCookie_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FriendChatCookie__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pubkey",
        .dataTypeSpecific.className = NULL,
        .number = FriendChatCookie_FieldNumber_Pubkey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FriendChatCookie__storage_, pubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FriendChatCookie class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FriendChatCookie__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FriendInfo

@implementation FriendInfo

@dynamic username;
@dynamic avatar;
@dynamic pubKey;
@dynamic uid;
@dynamic common;
@dynamic source;
@dynamic remark;
@dynamic connectId;

typedef struct FriendInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t source;
  NSString *username;
  NSString *avatar;
  NSString *pubKey;
  NSString *uid;
  NSString *remark;
  NSString *connectId;
} FriendInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = FriendInfo_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FriendInfo__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = FriendInfo_FieldNumber_Avatar,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FriendInfo__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = FriendInfo_FieldNumber_PubKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FriendInfo__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = FriendInfo_FieldNumber_Uid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FriendInfo__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "common",
        .dataTypeSpecific.className = NULL,
        .number = FriendInfo_FieldNumber_Common,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = FriendInfo_FieldNumber_Source,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(FriendInfo__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = FriendInfo_FieldNumber_Remark,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(FriendInfo__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "connectId",
        .dataTypeSpecific.className = NULL,
        .number = FriendInfo_FieldNumber_ConnectId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(FriendInfo__storage_, connectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FriendInfo class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FriendInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RelationShip

@implementation RelationShip

@dynamic version;
@dynamic friendsArray, friendsArray_Count;

typedef struct RelationShip__storage_ {
  uint32_t _has_storage_[1];
  NSString *version;
  NSMutableArray *friendsArray;
} RelationShip__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = RelationShip_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RelationShip__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "friendsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FriendInfo),
        .number = RelationShip_FieldNumber_FriendsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RelationShip__storage_, friendsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RelationShip class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RelationShip__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserCommonGroups

@implementation UserCommonGroups

@dynamic groupsArray, groupsArray_Count;

typedef struct UserCommonGroups__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *groupsArray;
} UserCommonGroups__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GroupInfo),
        .number = UserCommonGroups_FieldNumber_GroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserCommonGroups__storage_, groupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserCommonGroups class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserCommonGroups__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMember

@implementation GroupMember

@dynamic username;
@dynamic avatar;
@dynamic uid;
@dynamic role;
@dynamic nick;
@dynamic pubKey;
@dynamic connectId;

typedef struct GroupMember__storage_ {
  uint32_t _has_storage_[1];
  int32_t role;
  NSString *username;
  NSString *avatar;
  NSString *uid;
  NSString *nick;
  NSString *pubKey;
  NSString *connectId;
} GroupMember__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = GroupMember_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMember__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = GroupMember_FieldNumber_Avatar,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMember__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = GroupMember_FieldNumber_Uid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupMember__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "role",
        .dataTypeSpecific.className = NULL,
        .number = GroupMember_FieldNumber_Role,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupMember__storage_, role),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "nick",
        .dataTypeSpecific.className = NULL,
        .number = GroupMember_FieldNumber_Nick,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GroupMember__storage_, nick),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = GroupMember_FieldNumber_PubKey,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GroupMember__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "connectId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMember_FieldNumber_ConnectId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GroupMember__storage_, connectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupMember class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMember__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Group

@implementation Group

@dynamic identifier;
@dynamic name;
@dynamic summary;
@dynamic public_p;
@dynamic reviewed;
@dynamic avatar;

typedef struct Group__storage_ {
  uint32_t _has_storage_[1];
  NSString *identifier;
  NSString *name;
  NSString *summary;
  NSString *avatar;
} Group__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = Group_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Group__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Group_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Group__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "summary",
        .dataTypeSpecific.className = NULL,
        .number = Group_FieldNumber_Summary,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Group__storage_, summary),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "public_p",
        .dataTypeSpecific.className = NULL,
        .number = Group_FieldNumber_Public_p,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "reviewed",
        .dataTypeSpecific.className = NULL,
        .number = Group_FieldNumber_Reviewed,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = Group_FieldNumber_Avatar,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Group__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Group class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Group__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupInfo

@implementation GroupInfo

@dynamic hasGroup, group;
@dynamic membersArray, membersArray_Count;
@dynamic backup;
@dynamic ecdh;

typedef struct GroupInfo__storage_ {
  uint32_t _has_storage_[1];
  Group *group;
  NSMutableArray *membersArray;
  NSString *backup;
  NSString *ecdh;
} GroupInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "group",
        .dataTypeSpecific.className = GPBStringifySymbol(Group),
        .number = GroupInfo_FieldNumber_Group,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, group),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "membersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GroupMember),
        .number = GroupInfo_FieldNumber_MembersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, membersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "backup",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfo_FieldNumber_Backup,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, backup),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ecdh",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfo_FieldNumber_Ecdh,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, ecdh),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupInfo class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncUserRelationship

@implementation SyncUserRelationship

@dynamic hasRelationShip, relationShip;
@dynamic hasUserCommonGroups, userCommonGroups;

typedef struct SyncUserRelationship__storage_ {
  uint32_t _has_storage_[1];
  RelationShip *relationShip;
  UserCommonGroups *userCommonGroups;
} SyncUserRelationship__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "relationShip",
        .dataTypeSpecific.className = GPBStringifySymbol(RelationShip),
        .number = SyncUserRelationship_FieldNumber_RelationShip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncUserRelationship__storage_, relationShip),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userCommonGroups",
        .dataTypeSpecific.className = GPBStringifySymbol(UserCommonGroups),
        .number = SyncUserRelationship_FieldNumber_UserCommonGroups,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SyncUserRelationship__storage_, userCommonGroups),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SyncUserRelationship class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncUserRelationship__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\014\000\002\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncBadge

@implementation SyncBadge

@dynamic badge;

typedef struct SyncBadge__storage_ {
  uint32_t _has_storage_[1];
  int32_t badge;
} SyncBadge__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "badge",
        .dataTypeSpecific.className = NULL,
        .number = SyncBadge_FieldNumber_Badge,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncBadge__storage_, badge),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SyncBadge class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncBadge__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NOInterest

@implementation NOInterest

@dynamic uid;

typedef struct NOInterest__storage_ {
  uint32_t _has_storage_[1];
  NSString *uid;
} NOInterest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = NOInterest_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NOInterest__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NOInterest class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NOInterest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeviceToken

@implementation DeviceToken

@dynamic apnsDeviceToken;
@dynamic xgDeviceToken;
@dynamic gcmDeviceToken;
@dynamic pushType;
@dynamic deviceId;
@dynamic locale;

typedef struct DeviceToken__storage_ {
  uint32_t _has_storage_[1];
  NSString *apnsDeviceToken;
  NSString *xgDeviceToken;
  NSString *gcmDeviceToken;
  NSString *pushType;
  NSString *deviceId;
  NSString *locale;
} DeviceToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "apnsDeviceToken",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_ApnsDeviceToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, apnsDeviceToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "xgDeviceToken",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_XgDeviceToken,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, xgDeviceToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gcmDeviceToken",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_GcmDeviceToken,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, gcmDeviceToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushType",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_PushType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, pushType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_DeviceId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "locale",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_Locale,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, locale),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeviceToken class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeviceToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateSession

@implementation UpdateSession

@dynamic uid;
@dynamic mute;

typedef struct UpdateSession__storage_ {
  uint32_t _has_storage_[1];
  NSString *uid;
} UpdateSession__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = UpdateSession_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateSession__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mute",
        .dataTypeSpecific.className = NULL,
        .number = UpdateSession_FieldNumber_Mute,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateSession class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateSession__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CommandMessage

@implementation CommandMessage

@dynamic commandId;
@dynamic commandExtension;
@dynamic hasTransferData, transferData;
@dynamic hasCookieData, cookieData;
@dynamic hasChatCookie, chatCookie;

typedef struct CommandMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t commandExtension;
  NSString *commandId;
  IMTransferData *transferData;
  ChatCookieData *cookieData;
  ChatCacheCookie *chatCookie;
} CommandMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "commandId",
        .dataTypeSpecific.className = NULL,
        .number = CommandMessage_FieldNumber_CommandId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CommandMessage__storage_, commandId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "commandExtension",
        .dataTypeSpecific.className = NULL,
        .number = CommandMessage_FieldNumber_CommandExtension,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CommandMessage__storage_, commandExtension),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "transferData",
        .dataTypeSpecific.className = GPBStringifySymbol(IMTransferData),
        .number = CommandMessage_FieldNumber_TransferData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CommandMessage__storage_, transferData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cookieData",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatCookieData),
        .number = CommandMessage_FieldNumber_CookieData,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CommandMessage__storage_, cookieData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chatCookie",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatCacheCookie),
        .number = CommandMessage_FieldNumber_ChatCookie,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CommandMessage__storage_, chatCookie),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CommandMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CommandMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\n\000\005\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageDidRead

@implementation MessageDidRead

@dynamic msgId;
@dynamic msgOwer;

typedef struct MessageDidRead__storage_ {
  uint32_t _has_storage_[1];
  NSString *msgId;
  NSString *msgOwer;
} MessageDidRead__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = MessageDidRead_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageDidRead__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgOwer",
        .dataTypeSpecific.className = NULL,
        .number = MessageDidRead_FieldNumber_MsgOwer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageDidRead__storage_, msgOwer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageDidRead class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageDidRead__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CommandStauts

@implementation CommandStauts

@dynamic status;

typedef struct CommandStauts__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
} CommandStauts__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = CommandStauts_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CommandStauts__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CommandStauts class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CommandStauts__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReceiveFriendRequest

@implementation ReceiveFriendRequest

@dynamic hasSender, sender;
@dynamic tips;
@dynamic source;

typedef struct ReceiveFriendRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t source;
  UserInfo *sender;
  NSString *tips;
} ReceiveFriendRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sender",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = ReceiveFriendRequest_FieldNumber_Sender,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReceiveFriendRequest__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = ReceiveFriendRequest_FieldNumber_Tips,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ReceiveFriendRequest__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = ReceiveFriendRequest_FieldNumber_Source,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ReceiveFriendRequest__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReceiveFriendRequest class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReceiveFriendRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChangeRecords

@implementation ChangeRecords

@dynamic version;
@dynamic changeRecordsArray, changeRecordsArray_Count;

typedef struct ChangeRecords__storage_ {
  uint32_t _has_storage_[1];
  NSString *version;
  NSMutableArray *changeRecordsArray;
} ChangeRecords__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = ChangeRecords_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChangeRecords__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "changeRecordsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChangeRecord),
        .number = ChangeRecords_FieldNumber_ChangeRecordsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChangeRecords__storage_, changeRecordsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChangeRecords class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChangeRecords__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000changeRecords\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChangeRecord

@implementation ChangeRecord

@dynamic category;
@dynamic hasUserInfo, userInfo;

typedef struct ChangeRecord__storage_ {
  uint32_t _has_storage_[1];
  NSString *category;
  UserInfo *userInfo;
} ChangeRecord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = ChangeRecord_FieldNumber_Category,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChangeRecord__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = ChangeRecord_FieldNumber_UserInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChangeRecord__storage_, userInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChangeRecord class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChangeRecord__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FriendListChange

@implementation FriendListChange

@dynamic hasChange, change;
@dynamic version;

typedef struct FriendListChange__storage_ {
  uint32_t _has_storage_[1];
  ChangeRecord *change;
  NSString *version;
} FriendListChange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "change",
        .dataTypeSpecific.className = GPBStringifySymbol(ChangeRecord),
        .number = FriendListChange_FieldNumber_Change,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FriendListChange__storage_, change),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = FriendListChange_FieldNumber_Version,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FriendListChange__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FriendListChange class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FriendListChange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExternalRedPackageInfo

@implementation ExternalRedPackageInfo

@dynamic hashId;
@dynamic hasSender, sender;
@dynamic tips;
@dynamic msgId;
@dynamic system;

typedef struct ExternalRedPackageInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *hashId;
  UserInfo *sender;
  NSString *tips;
  NSString *msgId;
} ExternalRedPackageInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = ExternalRedPackageInfo_FieldNumber_HashId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExternalRedPackageInfo__storage_, hashId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = ExternalRedPackageInfo_FieldNumber_Sender,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExternalRedPackageInfo__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = ExternalRedPackageInfo_FieldNumber_Tips,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ExternalRedPackageInfo__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = ExternalRedPackageInfo_FieldNumber_MsgId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ExternalRedPackageInfo__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "system",
        .dataTypeSpecific.className = NULL,
        .number = ExternalRedPackageInfo_FieldNumber_System,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExternalRedPackageInfo class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExternalRedPackageInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupChange

@implementation GroupChange

@dynamic identifier;
@dynamic changeType;
@dynamic detail;
@dynamic count;
@dynamic hasInviteBy, inviteBy;

typedef struct GroupChange__storage_ {
  uint32_t _has_storage_[1];
  int32_t changeType;
  int32_t count;
  NSString *identifier;
  NSData *detail;
  UserInfo *inviteBy;
} GroupChange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = GroupChange_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupChange__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "changeType",
        .dataTypeSpecific.className = NULL,
        .number = GroupChange_FieldNumber_ChangeType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupChange__storage_, changeType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "detail",
        .dataTypeSpecific.className = NULL,
        .number = GroupChange_FieldNumber_Detail,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupChange__storage_, detail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = GroupChange_FieldNumber_Count,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupChange__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "inviteBy",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = GroupChange_FieldNumber_InviteBy,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GroupChange__storage_, inviteBy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupChange class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupChange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserInfo

@implementation UserInfo

@dynamic username;
@dynamic avatar;
@dynamic pubKey;
@dynamic uid;
@dynamic recommend;
@dynamic connectId;
@dynamic source;
@dynamic createdAt;
@dynamic updateConnectId;

typedef struct UserInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t source;
  NSString *username;
  NSString *avatar;
  NSString *pubKey;
  NSString *uid;
  NSString *connectId;
  int64_t createdAt;
} UserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserInfo__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Avatar,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserInfo__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_PubKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserInfo__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Uid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserInfo__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "recommend",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Recommend,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "connectId",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_ConnectId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UserInfo__storage_, connectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Source,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UserInfo__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createdAt",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_CreatedAt,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(UserInfo__storage_, createdAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "updateConnectId",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_UpdateConnectId,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserInfo class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProducerMsgDetail

@implementation ProducerMsgDetail

@dynamic type;
@dynamic ext;
@dynamic data_p;

typedef struct ProducerMsgDetail__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  int32_t ext;
  NSData *data_p;
} ProducerMsgDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = ProducerMsgDetail_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProducerMsgDetail__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "ext",
        .dataTypeSpecific.className = NULL,
        .number = ProducerMsgDetail_FieldNumber_Ext,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProducerMsgDetail__storage_, ext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = ProducerMsgDetail_FieldNumber_Data_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ProducerMsgDetail__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProducerMsgDetail class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProducerMsgDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QuitMessage

@implementation QuitMessage

@dynamic deviceName;

typedef struct QuitMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *deviceName;
} QuitMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = QuitMessage_FieldNumber_DeviceName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QuitMessage__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[QuitMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QuitMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMResponse

@implementation IMResponse

@dynamic sign;
@dynamic hasCipherData, cipherData;

typedef struct IMResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *sign;
  GcmData *cipherData;
} IMResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = IMResponse_FieldNumber_Sign,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMResponse__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cipherData",
        .dataTypeSpecific.className = GPBStringifySymbol(GcmData),
        .number = IMResponse_FieldNumber_CipherData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMResponse__storage_, cipherData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMResponse class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OfflineMsg

@implementation OfflineMsg

@dynamic msgId;
@dynamic hasBody, body;

typedef struct OfflineMsg__storage_ {
  uint32_t _has_storage_[1];
  NSString *msgId;
  ProducerMsgDetail *body;
} OfflineMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMsg_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OfflineMsg__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "body",
        .dataTypeSpecific.className = GPBStringifySymbol(ProducerMsgDetail),
        .number = OfflineMsg_FieldNumber_Body,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OfflineMsg__storage_, body),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OfflineMsg class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OfflineMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OfflineMsgs

@implementation OfflineMsgs

@dynamic offlineMsgsArray, offlineMsgsArray_Count;
@dynamic completed;

typedef struct OfflineMsgs__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *offlineMsgsArray;
} OfflineMsgs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "offlineMsgsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(OfflineMsg),
        .number = OfflineMsgs_FieldNumber_OfflineMsgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OfflineMsgs__storage_, offlineMsgsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "completed",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMsgs_FieldNumber_Completed,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OfflineMsgs class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OfflineMsgs__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000offlineMsgs\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NoticeMessage

@implementation NoticeMessage

@dynamic category;
@dynamic body;
@dynamic msgId;

typedef struct NoticeMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t category;
  NSData *body;
  NSString *msgId;
} NoticeMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = NoticeMessage_FieldNumber_Category,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NoticeMessage__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "body",
        .dataTypeSpecific.className = NULL,
        .number = NoticeMessage_FieldNumber_Body,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NoticeMessage__storage_, body),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = NoticeMessage_FieldNumber_MsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NoticeMessage__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NoticeMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NoticeMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GcmData

@implementation GcmData

@dynamic iv;
@dynamic aad;
@dynamic tag;
@dynamic ciphertext;

typedef struct GcmData__storage_ {
  uint32_t _has_storage_[1];
  NSData *iv;
  NSData *aad;
  NSData *tag;
  NSData *ciphertext;
} GcmData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "iv",
        .dataTypeSpecific.className = NULL,
        .number = GcmData_FieldNumber_Iv,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GcmData__storage_, iv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "aad",
        .dataTypeSpecific.className = NULL,
        .number = GcmData_FieldNumber_Aad,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GcmData__storage_, aad),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tag",
        .dataTypeSpecific.className = NULL,
        .number = GcmData_FieldNumber_Tag,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GcmData__storage_, tag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ciphertext",
        .dataTypeSpecific.className = NULL,
        .number = GcmData_FieldNumber_Ciphertext,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GcmData__storage_, ciphertext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GcmData class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GcmData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMTransferData

@implementation IMTransferData

@dynamic sign;
@dynamic hasCipherData, cipherData;

typedef struct IMTransferData__storage_ {
  uint32_t _has_storage_[1];
  NSString *sign;
  GcmData *cipherData;
} IMTransferData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = IMTransferData_FieldNumber_Sign,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMTransferData__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cipherData",
        .dataTypeSpecific.className = GPBStringifySymbol(GcmData),
        .number = IMTransferData_FieldNumber_CipherData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMTransferData__storage_, cipherData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMTransferData class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMTransferData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Command

@implementation Command

@dynamic msgId;
@dynamic detail;
@dynamic errNo;
@dynamic msg;

typedef struct Command__storage_ {
  uint32_t _has_storage_[1];
  int32_t errNo;
  NSString *msgId;
  NSData *detail;
  NSString *msg;
} Command__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = Command_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Command__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "detail",
        .dataTypeSpecific.className = NULL,
        .number = Command_FieldNumber_Detail,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Command__storage_, detail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "errNo",
        .dataTypeSpecific.className = NULL,
        .number = Command_FieldNumber_ErrNo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Command__storage_, errNo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = Command_FieldNumber_Msg,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Command__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Command class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Command__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RichMedia

@implementation RichMedia

@dynamic thumbnail;
@dynamic entity;

typedef struct RichMedia__storage_ {
  uint32_t _has_storage_[1];
  NSData *thumbnail;
  NSData *entity;
} RichMedia__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "thumbnail",
        .dataTypeSpecific.className = NULL,
        .number = RichMedia_FieldNumber_Thumbnail,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RichMedia__storage_, thumbnail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "entity",
        .dataTypeSpecific.className = NULL,
        .number = RichMedia_FieldNumber_Entity,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RichMedia__storage_, entity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RichMedia class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RichMedia__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MediaFile

@implementation MediaFile

@dynamic pubKey;
@dynamic sign;
@dynamic hasCipherData, cipherData;

typedef struct MediaFile__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubKey;
  NSString *sign;
  GcmData *cipherData;
} MediaFile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = MediaFile_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MediaFile__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = MediaFile_FieldNumber_Sign,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MediaFile__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cipherData",
        .dataTypeSpecific.className = GPBStringifySymbol(GcmData),
        .number = MediaFile_FieldNumber_CipherData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MediaFile__storage_, cipherData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MediaFile class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MediaFile__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StructData

@implementation StructData

@dynamic random;
@dynamic plainData;

typedef struct StructData__storage_ {
  uint32_t _has_storage_[1];
  NSData *random;
  NSData *plainData;
} StructData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "random",
        .dataTypeSpecific.className = NULL,
        .number = StructData_FieldNumber_Random,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StructData__storage_, random),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "plainData",
        .dataTypeSpecific.className = NULL,
        .number = StructData_FieldNumber_PlainData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StructData__storage_, plainData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StructData class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StructData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessagePost

@implementation MessagePost

@dynamic pubKey;
@dynamic sign;
@dynamic hasMsgData, msgData;

typedef struct MessagePost__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubKey;
  NSString *sign;
  MessageData *msgData;
} MessagePost__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = MessagePost_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessagePost__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = MessagePost_FieldNumber_Sign,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessagePost__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgData",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageData),
        .number = MessagePost_FieldNumber_MsgData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessagePost__storage_, msgData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessagePost class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessagePost__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Reviewed

@implementation Reviewed

@dynamic category;
@dynamic identifier;
@dynamic tips;
@dynamic hasUserInfo, userInfo;
@dynamic verificationCode;
@dynamic source;
@dynamic name;

typedef struct Reviewed__storage_ {
  uint32_t _has_storage_[1];
  int32_t category;
  int32_t source;
  NSString *identifier;
  NSString *tips;
  UserInfo *userInfo;
  NSString *verificationCode;
  NSString *name;
} Reviewed__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = Reviewed_FieldNumber_Category,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Reviewed__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = Reviewed_FieldNumber_Identifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Reviewed__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = Reviewed_FieldNumber_Tips,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Reviewed__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = Reviewed_FieldNumber_UserInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Reviewed__storage_, userInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "verificationCode",
        .dataTypeSpecific.className = NULL,
        .number = Reviewed_FieldNumber_VerificationCode,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Reviewed__storage_, verificationCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = Reviewed_FieldNumber_Source,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Reviewed__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Reviewed_FieldNumber_Name,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Reviewed__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Reviewed class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Reviewed__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\010\000\005\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReviewedStatus

@implementation ReviewedStatus

@dynamic hasReview, review;
@dynamic refused;
@dynamic newaccept;

typedef struct ReviewedStatus__storage_ {
  uint32_t _has_storage_[1];
  Reviewed *review;
} ReviewedStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "review",
        .dataTypeSpecific.className = GPBStringifySymbol(Reviewed),
        .number = ReviewedStatus_FieldNumber_Review,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReviewedStatus__storage_, review),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "refused",
        .dataTypeSpecific.className = NULL,
        .number = ReviewedStatus_FieldNumber_Refused,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "newaccept",
        .dataTypeSpecific.className = NULL,
        .number = ReviewedStatus_FieldNumber_Newaccept,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReviewedStatus class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReviewedStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SystemRedPackage

@implementation SystemRedPackage

@dynamic amount;
@dynamic hashId;
@dynamic tips;

typedef struct SystemRedPackage__storage_ {
  uint32_t _has_storage_[1];
  NSString *hashId;
  NSString *tips;
  int64_t amount;
} SystemRedPackage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = SystemRedPackage_FieldNumber_Amount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SystemRedPackage__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = SystemRedPackage_FieldNumber_HashId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SystemRedPackage__storage_, hashId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = SystemRedPackage_FieldNumber_Tips,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SystemRedPackage__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SystemRedPackage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SystemRedPackage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateMobileBind

@implementation UpdateMobileBind

@dynamic username;

typedef struct UpdateMobileBind__storage_ {
  uint32_t _has_storage_[1];
  NSString *username;
} UpdateMobileBind__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = UpdateMobileBind_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateMobileBind__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateMobileBind class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateMobileBind__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddressNotify

@implementation AddressNotify

@dynamic txId;
@dynamic amount;

typedef struct AddressNotify__storage_ {
  uint32_t _has_storage_[1];
  NSString *txId;
  int64_t amount;
} AddressNotify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txId",
        .dataTypeSpecific.className = NULL,
        .number = AddressNotify_FieldNumber_TxId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddressNotify__storage_, txId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = AddressNotify_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddressNotify__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddressNotify class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddressNotify__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\004\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemoveGroup

@implementation RemoveGroup

@dynamic name;
@dynamic groupId;

typedef struct RemoveGroup__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *groupId;
} RemoveGroup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = RemoveGroup_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RemoveGroup__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = RemoveGroup_FieldNumber_GroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RemoveGroup__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemoveGroup class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemoveGroup__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Announcement

@implementation Announcement

@dynamic createdAt;
@dynamic title;
@dynamic content;
@dynamic URL;
@dynamic category;
@dynamic desc;
@dynamic coversURL;
@dynamic version;

typedef struct Announcement__storage_ {
  uint32_t _has_storage_[1];
  float createdAt;
  int32_t category;
  NSString *title;
  NSString *content;
  NSString *URL;
  NSString *desc;
  NSString *coversURL;
  NSString *version;
} Announcement__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "createdAt",
        .dataTypeSpecific.className = NULL,
        .number = Announcement_FieldNumber_CreatedAt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Announcement__storage_, createdAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = Announcement_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Announcement__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = Announcement_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Announcement__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = Announcement_FieldNumber_URL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Announcement__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = Announcement_FieldNumber_Category,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Announcement__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = Announcement_FieldNumber_Desc,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Announcement__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "coversURL",
        .dataTypeSpecific.className = NULL,
        .number = Announcement_FieldNumber_CoversURL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Announcement__storage_, coversURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = Announcement_FieldNumber_Version,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Announcement__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Announcement class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Announcement__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004!!!\000\007\006\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SystemRedpackgeNotice

@implementation SystemRedpackgeNotice

@dynamic hasReceiver, receiver;
@dynamic amount;
@dynamic hashid;

typedef struct SystemRedpackgeNotice__storage_ {
  uint32_t _has_storage_[1];
  UserInfo *receiver;
  NSString *hashid;
  int64_t amount;
} SystemRedpackgeNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "receiver",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = SystemRedpackgeNotice_FieldNumber_Receiver,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SystemRedpackgeNotice__storage_, receiver),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = SystemRedpackgeNotice_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SystemRedpackgeNotice__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hashid",
        .dataTypeSpecific.className = NULL,
        .number = SystemRedpackgeNotice_FieldNumber_Hashid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SystemRedpackgeNotice__storage_, hashid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SystemRedpackgeNotice class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SystemRedpackgeNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReviewedResponse

@implementation ReviewedResponse

@dynamic category;
@dynamic identifier;
@dynamic name;
@dynamic success;

typedef struct ReviewedResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t category;
  NSString *identifier;
  NSString *name;
} ReviewedResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = ReviewedResponse_FieldNumber_Category,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReviewedResponse__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = ReviewedResponse_FieldNumber_Identifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ReviewedResponse__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ReviewedResponse_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ReviewedResponse__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = ReviewedResponse_FieldNumber_Success,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReviewedResponse class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReviewedResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupApplyChange

@implementation GroupApplyChange

@dynamic verificationCode;
@dynamic tips;
@dynamic source;
@dynamic tipsHistoryArray, tipsHistoryArray_Count;

typedef struct GroupApplyChange__storage_ {
  uint32_t _has_storage_[1];
  int32_t source;
  NSString *verificationCode;
  NSString *tips;
  NSMutableArray *tipsHistoryArray;
} GroupApplyChange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "verificationCode",
        .dataTypeSpecific.className = NULL,
        .number = GroupApplyChange_FieldNumber_VerificationCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupApplyChange__storage_, verificationCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = GroupApplyChange_FieldNumber_Tips,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupApplyChange__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = GroupApplyChange_FieldNumber_Source,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupApplyChange__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tipsHistoryArray",
        .dataTypeSpecific.className = NULL,
        .number = GroupApplyChange_FieldNumber_TipsHistoryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupApplyChange__storage_, tipsHistoryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupApplyChange class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupApplyChange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SystemTransferPackage

@implementation SystemTransferPackage

@dynamic amount;
@dynamic txid;
@dynamic tips;
@dynamic sender;

typedef struct SystemTransferPackage__storage_ {
  uint32_t _has_storage_[1];
  NSString *txid;
  NSString *tips;
  NSString *sender;
  int64_t amount;
} SystemTransferPackage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = SystemTransferPackage_FieldNumber_Amount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SystemTransferPackage__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = SystemTransferPackage_FieldNumber_Txid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SystemTransferPackage__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = SystemTransferPackage_FieldNumber_Tips,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SystemTransferPackage__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = NULL,
        .number = SystemTransferPackage_FieldNumber_Sender,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SystemTransferPackage__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SystemTransferPackage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SystemTransferPackage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MSMessage

@implementation MSMessage

@dynamic msgId;
@dynamic body;
@dynamic category;

typedef struct MSMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t category;
  NSString *msgId;
  NSData *body;
} MSMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = MSMessage_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MSMessage__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "body",
        .dataTypeSpecific.className = NULL,
        .number = MSMessage_FieldNumber_Body,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MSMessage__storage_, body),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = MSMessage_FieldNumber_Category,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MSMessage__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MSMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MSMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RejectMessage

@implementation RejectMessage

@dynamic msgId;
@dynamic uid;
@dynamic status;
@dynamic data_p;

typedef struct RejectMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
  NSString *msgId;
  NSString *uid;
  NSData *data_p;
} RejectMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = RejectMessage_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RejectMessage__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = RejectMessage_FieldNumber_Uid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RejectMessage__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = RejectMessage_FieldNumber_Status,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RejectMessage__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = RejectMessage_FieldNumber_Data_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RejectMessage__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RejectMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RejectMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatCacheCookie

@implementation ChatCacheCookie

@dynamic chatPubKey;
@dynamic salt;
@dynamic chatPrivkey;

typedef struct ChatCacheCookie__storage_ {
  uint32_t _has_storage_[1];
  NSString *chatPubKey;
  NSData *salt;
  NSString *chatPrivkey;
} ChatCacheCookie__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatPubKey",
        .dataTypeSpecific.className = NULL,
        .number = ChatCacheCookie_FieldNumber_ChatPubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatCacheCookie__storage_, chatPubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "salt",
        .dataTypeSpecific.className = NULL,
        .number = ChatCacheCookie_FieldNumber_Salt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatCacheCookie__storage_, salt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "chatPrivkey",
        .dataTypeSpecific.className = NULL,
        .number = ChatCacheCookie_FieldNumber_ChatPrivkey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatCacheCookie__storage_, chatPrivkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatCacheCookie class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatCacheCookie__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateGroupMessage

@implementation CreateGroupMessage

@dynamic identifier;
@dynamic secretKey;

typedef struct CreateGroupMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *identifier;
  NSString *secretKey;
} CreateGroupMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = CreateGroupMessage_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateGroupMessage__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "secretKey",
        .dataTypeSpecific.className = NULL,
        .number = CreateGroupMessage_FieldNumber_SecretKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CreateGroupMessage__storage_, secretKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateGroupMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateGroupMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatCookie

@implementation ChatCookie

@dynamic sign;
@dynamic hasData_p, data_p;

typedef struct ChatCookie__storage_ {
  uint32_t _has_storage_[1];
  NSString *sign;
  ChatCookieData *data_p;
} ChatCookie__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = ChatCookie_FieldNumber_Sign,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatCookie__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatCookieData),
        .number = ChatCookie_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatCookie__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatCookie class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatCookie__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Ack

@implementation Ack

@dynamic msgId;
@dynamic type;

typedef struct Ack__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  NSString *msgId;
} Ack__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = Ack_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Ack__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = Ack_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Ack__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Ack class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Ack__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OfflineMsgAck

@implementation OfflineMsgAck

@dynamic msgIdsArray, msgIdsArray_Count;

typedef struct OfflineMsgAck__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *msgIdsArray;
} OfflineMsgAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMsgAck_FieldNumber_MsgIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OfflineMsgAck__storage_, msgIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OfflineMsgAck class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OfflineMsgAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatCookieData

@implementation ChatCookieData

@dynamic chatPubKey;
@dynamic salt;
@dynamic expired;

typedef struct ChatCookieData__storage_ {
  uint32_t _has_storage_[1];
  NSString *chatPubKey;
  NSData *salt;
  int64_t expired;
} ChatCookieData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatPubKey",
        .dataTypeSpecific.className = NULL,
        .number = ChatCookieData_FieldNumber_ChatPubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatCookieData__storage_, chatPubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "salt",
        .dataTypeSpecific.className = NULL,
        .number = ChatCookieData_FieldNumber_Salt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatCookieData__storage_, salt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "expired",
        .dataTypeSpecific.className = NULL,
        .number = ChatCookieData_FieldNumber_Expired,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatCookieData__storage_, expired),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatCookieData class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatCookieData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageData

@implementation MessageData

@dynamic hasChatMsg, chatMsg;
@dynamic hasChatSession, chatSession;

typedef struct MessageData__storage_ {
  uint32_t _has_storage_[1];
  ChatMessage *chatMsg;
  ChatSession *chatSession;
} MessageData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatMsg",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatMessage),
        .number = MessageData_FieldNumber_ChatMsg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageData__storage_, chatMsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chatSession",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatSession),
        .number = MessageData_FieldNumber_ChatSession,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageData__storage_, chatSession),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageData class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatSession

@implementation ChatSession

@dynamic salt;
@dynamic ver;
@dynamic pubKey;

typedef struct ChatSession__storage_ {
  uint32_t _has_storage_[1];
  NSData *salt;
  NSData *ver;
  NSString *pubKey;
} ChatSession__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "salt",
        .dataTypeSpecific.className = NULL,
        .number = ChatSession_FieldNumber_Salt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatSession__storage_, salt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ver",
        .dataTypeSpecific.className = NULL,
        .number = ChatSession_FieldNumber_Ver,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatSession__storage_, ver),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = ChatSession_FieldNumber_PubKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatSession__storage_, pubKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatSession class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatSession__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatMessage

@implementation ChatMessage

@dynamic msgId;
@dynamic msgTime;
@dynamic from;
@dynamic to;
@dynamic hasCipherData, cipherData;
@dynamic chatType;
@dynamic msgType;
@dynamic ext;
@dynamic sendStatus;

typedef struct ChatMessage__storage_ {
  uint32_t _has_storage_[1];
  ChatType chatType;
  int32_t msgType;
  int32_t sendStatus;
  NSString *msgId;
  NSString *from;
  NSString *to;
  GcmData *cipherData;
  NSString *ext;
  int64_t msgTime;
} ChatMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgTime",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_MsgTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, msgTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_From,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, from),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "to",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_To,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, to),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cipherData",
        .dataTypeSpecific.className = GPBStringifySymbol(GcmData),
        .number = ChatMessage_FieldNumber_CipherData,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, cipherData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chatType",
        .dataTypeSpecific.enumDescFunc = ChatType_EnumDescriptor,
        .number = ChatMessage_FieldNumber_ChatType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, chatType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgType",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_MsgType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, msgType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "ext",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_Ext,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, ext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sendStatus",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_SendStatus,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, sendStatus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ChatMessage_ChatType_RawValue(ChatMessage *message) {
  GPBDescriptor *descriptor = [ChatMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChatMessage_FieldNumber_ChatType];
  return GPBGetMessageInt32Field(message, field);
}

void SetChatMessage_ChatType_RawValue(ChatMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [ChatMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChatMessage_FieldNumber_ChatType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - MessageUserInfo

@implementation MessageUserInfo

@dynamic uid;
@dynamic username;
@dynamic avatar;

typedef struct MessageUserInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *uid;
  NSString *username;
  NSString *avatar;
} MessageUserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = MessageUserInfo_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageUserInfo__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = MessageUserInfo_FieldNumber_Username,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageUserInfo__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = MessageUserInfo_FieldNumber_Avatar,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessageUserInfo__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageUserInfo class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageUserInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TimeMessage

@implementation TimeMessage

@dynamic time;

typedef struct TimeMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *time;
} TimeMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = TimeMessage_FieldNumber_Time,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TimeMessage__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TimeMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TimeMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TextMessage

@implementation TextMessage

@dynamic content;
@dynamic atUidsArray, atUidsArray_Count;
@dynamic snapTime;

typedef struct TextMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *content;
  NSMutableArray *atUidsArray;
  int64_t snapTime;
} TextMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = TextMessage_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TextMessage__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "atUidsArray",
        .dataTypeSpecific.className = NULL,
        .number = TextMessage_FieldNumber_AtUidsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TextMessage__storage_, atUidsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "snapTime",
        .dataTypeSpecific.className = NULL,
        .number = TextMessage_FieldNumber_SnapTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TextMessage__storage_, snapTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmotionMessage

@implementation EmotionMessage

@dynamic content;
@dynamic snapTime;

typedef struct EmotionMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *content;
  int64_t snapTime;
} EmotionMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = EmotionMessage_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EmotionMessage__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "snapTime",
        .dataTypeSpecific.className = NULL,
        .number = EmotionMessage_FieldNumber_SnapTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EmotionMessage__storage_, snapTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmotionMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EmotionMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PhotoMessage

@implementation PhotoMessage

@dynamic URL;
@dynamic thum;
@dynamic size;
@dynamic imageWidth;
@dynamic imageHeight;
@dynamic snapTime;

typedef struct PhotoMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t imageWidth;
  int32_t imageHeight;
  NSString *URL;
  NSString *thum;
  NSString *size;
  int64_t snapTime;
} PhotoMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PhotoMessage_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PhotoMessage__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "thum",
        .dataTypeSpecific.className = NULL,
        .number = PhotoMessage_FieldNumber_Thum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PhotoMessage__storage_, thum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = PhotoMessage_FieldNumber_Size,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PhotoMessage__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imageWidth",
        .dataTypeSpecific.className = NULL,
        .number = PhotoMessage_FieldNumber_ImageWidth,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PhotoMessage__storage_, imageWidth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "imageHeight",
        .dataTypeSpecific.className = NULL,
        .number = PhotoMessage_FieldNumber_ImageHeight,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PhotoMessage__storage_, imageHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "snapTime",
        .dataTypeSpecific.className = NULL,
        .number = PhotoMessage_FieldNumber_SnapTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PhotoMessage__storage_, snapTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PhotoMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PhotoMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VoiceMessage

@implementation VoiceMessage

@dynamic URL;
@dynamic timeLength;
@dynamic snapTime;

typedef struct VoiceMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t timeLength;
  NSString *URL;
  int64_t snapTime;
} VoiceMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = VoiceMessage_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VoiceMessage__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeLength",
        .dataTypeSpecific.className = NULL,
        .number = VoiceMessage_FieldNumber_TimeLength,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VoiceMessage__storage_, timeLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "snapTime",
        .dataTypeSpecific.className = NULL,
        .number = VoiceMessage_FieldNumber_SnapTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VoiceMessage__storage_, snapTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VoiceMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VoiceMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VideoMessage

@implementation VideoMessage

@dynamic URL;
@dynamic cover;
@dynamic timeLength;
@dynamic size;
@dynamic imageWidth;
@dynamic imageHeight;
@dynamic snapTime;

typedef struct VideoMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t timeLength;
  int32_t size;
  int32_t imageWidth;
  int32_t imageHeight;
  NSString *URL;
  NSString *cover;
  int64_t snapTime;
} VideoMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = VideoMessage_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VideoMessage__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cover",
        .dataTypeSpecific.className = NULL,
        .number = VideoMessage_FieldNumber_Cover,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VideoMessage__storage_, cover),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeLength",
        .dataTypeSpecific.className = NULL,
        .number = VideoMessage_FieldNumber_TimeLength,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VideoMessage__storage_, timeLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = VideoMessage_FieldNumber_Size,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VideoMessage__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "imageWidth",
        .dataTypeSpecific.className = NULL,
        .number = VideoMessage_FieldNumber_ImageWidth,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(VideoMessage__storage_, imageWidth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "imageHeight",
        .dataTypeSpecific.className = NULL,
        .number = VideoMessage_FieldNumber_ImageHeight,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(VideoMessage__storage_, imageHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "snapTime",
        .dataTypeSpecific.className = NULL,
        .number = VideoMessage_FieldNumber_SnapTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(VideoMessage__storage_, snapTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VideoMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VideoMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CardMessage

@implementation CardMessage

@dynamic uid;
@dynamic username;
@dynamic avatar;

typedef struct CardMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *uid;
  NSString *username;
  NSString *avatar;
} CardMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = CardMessage_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CardMessage__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = CardMessage_FieldNumber_Username,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CardMessage__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = CardMessage_FieldNumber_Avatar,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CardMessage__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CardMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CardMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DestructMessage

@implementation DestructMessage

@dynamic time;

typedef struct DestructMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t time;
} DestructMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = DestructMessage_FieldNumber_Time,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DestructMessage__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DestructMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DestructMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReadReceiptMessage

@implementation ReadReceiptMessage

@dynamic messageId;

typedef struct ReadReceiptMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *messageId;
} ReadReceiptMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = ReadReceiptMessage_FieldNumber_MessageId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReadReceiptMessage__storage_, messageId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReadReceiptMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReadReceiptMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PaymentMessage

@implementation PaymentMessage

@dynamic paymentType;
@dynamic hashId;
@dynamic amount;
@dynamic memberSize;
@dynamic tips;

typedef struct PaymentMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t paymentType;
  int32_t memberSize;
  NSString *hashId;
  NSString *tips;
  int64_t amount;
} PaymentMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "paymentType",
        .dataTypeSpecific.className = NULL,
        .number = PaymentMessage_FieldNumber_PaymentType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PaymentMessage__storage_, paymentType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = PaymentMessage_FieldNumber_HashId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PaymentMessage__storage_, hashId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = PaymentMessage_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PaymentMessage__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "memberSize",
        .dataTypeSpecific.className = NULL,
        .number = PaymentMessage_FieldNumber_MemberSize,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PaymentMessage__storage_, memberSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = PaymentMessage_FieldNumber_Tips,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PaymentMessage__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PaymentMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PaymentMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransferMessage

@implementation TransferMessage

@dynamic transferType;
@dynamic hashId;
@dynamic amount;
@dynamic tips;

typedef struct TransferMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t transferType;
  NSString *hashId;
  NSString *tips;
  int64_t amount;
} TransferMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transferType",
        .dataTypeSpecific.className = NULL,
        .number = TransferMessage_FieldNumber_TransferType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransferMessage__storage_, transferType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = TransferMessage_FieldNumber_HashId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransferMessage__storage_, hashId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = TransferMessage_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransferMessage__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = TransferMessage_FieldNumber_Tips,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TransferMessage__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransferMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransferMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LuckPacketMessage

@implementation LuckPacketMessage

@dynamic hashId;
@dynamic luckyType;
@dynamic tips;
@dynamic amount;

typedef struct LuckPacketMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t luckyType;
  NSString *hashId;
  NSString *tips;
  int64_t amount;
} LuckPacketMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = LuckPacketMessage_FieldNumber_HashId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LuckPacketMessage__storage_, hashId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "luckyType",
        .dataTypeSpecific.className = NULL,
        .number = LuckPacketMessage_FieldNumber_LuckyType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LuckPacketMessage__storage_, luckyType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = LuckPacketMessage_FieldNumber_Tips,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LuckPacketMessage__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = LuckPacketMessage_FieldNumber_Amount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LuckPacketMessage__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LuckPacketMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LuckPacketMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LocationMessage

@implementation LocationMessage

@dynamic latitude;
@dynamic longitude;
@dynamic address;
@dynamic screenShot;
@dynamic imageWidth;
@dynamic imageHeight;

typedef struct LocationMessage__storage_ {
  uint32_t _has_storage_[1];
  float latitude;
  float longitude;
  int32_t imageWidth;
  int32_t imageHeight;
  NSString *address;
  NSString *screenShot;
} LocationMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = LocationMessage_FieldNumber_Latitude,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LocationMessage__storage_, latitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = LocationMessage_FieldNumber_Longitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LocationMessage__storage_, longitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = LocationMessage_FieldNumber_Address,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LocationMessage__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "screenShot",
        .dataTypeSpecific.className = NULL,
        .number = LocationMessage_FieldNumber_ScreenShot,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LocationMessage__storage_, screenShot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imageWidth",
        .dataTypeSpecific.className = NULL,
        .number = LocationMessage_FieldNumber_ImageWidth,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LocationMessage__storage_, imageWidth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "imageHeight",
        .dataTypeSpecific.className = NULL,
        .number = LocationMessage_FieldNumber_ImageHeight,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LocationMessage__storage_, imageHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LocationMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LocationMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NotifyMessage

@implementation NotifyMessage

@dynamic notifyType;
@dynamic content;
@dynamic extion;

typedef struct NotifyMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t notifyType;
  NSString *content;
  NSString *extion;
} NotifyMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "notifyType",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMessage_FieldNumber_NotifyType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NotifyMessage__storage_, notifyType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMessage_FieldNumber_Content,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NotifyMessage__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extion",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMessage_FieldNumber_Extion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NotifyMessage__storage_, extion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NotifyMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NotifyMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - JoinGroupMessage

@implementation JoinGroupMessage

@dynamic avatar;
@dynamic groupName;
@dynamic groupId;
@dynamic token;

typedef struct JoinGroupMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *avatar;
  NSString *groupName;
  NSString *groupId;
  NSString *token;
} JoinGroupMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = JoinGroupMessage_FieldNumber_Avatar,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(JoinGroupMessage__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.className = NULL,
        .number = JoinGroupMessage_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(JoinGroupMessage__storage_, groupName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = JoinGroupMessage_FieldNumber_GroupId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(JoinGroupMessage__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = JoinGroupMessage_FieldNumber_Token,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(JoinGroupMessage__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[JoinGroupMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(JoinGroupMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WebsiteMessage

@implementation WebsiteMessage

@dynamic URL;
@dynamic title;
@dynamic subtitle;
@dynamic img;

typedef struct WebsiteMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
  NSString *title;
  NSString *subtitle;
  NSString *img;
} WebsiteMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = WebsiteMessage_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WebsiteMessage__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = WebsiteMessage_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WebsiteMessage__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "subtitle",
        .dataTypeSpecific.className = NULL,
        .number = WebsiteMessage_FieldNumber_Subtitle,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WebsiteMessage__storage_, subtitle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "img",
        .dataTypeSpecific.className = NULL,
        .number = WebsiteMessage_FieldNumber_Img,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(WebsiteMessage__storage_, img),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WebsiteMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WebsiteMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
